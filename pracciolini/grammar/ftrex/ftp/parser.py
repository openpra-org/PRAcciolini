# Generated from ftrex_ftp.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,16,139,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,1,0,5,0,38,8,0,10,0,12,0,
        41,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,3,1,50,8,1,1,2,5,2,53,8,2,10,
        2,12,2,56,9,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,5,1,
        5,1,5,1,5,1,6,1,6,1,6,1,6,1,7,4,7,78,8,7,11,7,12,7,79,1,7,4,7,83,
        8,7,11,7,12,7,84,1,8,1,8,1,8,3,8,90,8,8,1,8,4,8,93,8,8,11,8,12,8,
        94,1,9,1,9,1,10,1,10,1,11,1,11,1,12,1,12,4,12,105,8,12,11,12,12,
        12,106,1,13,1,13,1,13,1,13,3,13,113,8,13,1,14,1,14,1,14,1,15,1,15,
        1,15,1,16,1,16,5,16,123,8,16,10,16,12,16,126,9,16,1,16,1,16,1,17,
        1,17,5,17,132,8,17,10,17,12,17,135,9,17,1,17,1,17,1,17,2,124,133,
        0,18,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,0,1,2,0,5,
        6,11,11,137,0,39,1,0,0,0,2,49,1,0,0,0,4,54,1,0,0,0,6,60,1,0,0,0,
        8,65,1,0,0,0,10,68,1,0,0,0,12,72,1,0,0,0,14,82,1,0,0,0,16,92,1,0,
        0,0,18,96,1,0,0,0,20,98,1,0,0,0,22,100,1,0,0,0,24,104,1,0,0,0,26,
        112,1,0,0,0,28,114,1,0,0,0,30,117,1,0,0,0,32,120,1,0,0,0,34,129,
        1,0,0,0,36,38,3,2,1,0,37,36,1,0,0,0,38,41,1,0,0,0,39,37,1,0,0,0,
        39,40,1,0,0,0,40,42,1,0,0,0,41,39,1,0,0,0,42,43,5,0,0,1,43,1,1,0,
        0,0,44,50,3,4,2,0,45,50,3,8,4,0,46,50,3,10,5,0,47,50,3,12,6,0,48,
        50,3,26,13,0,49,44,1,0,0,0,49,45,1,0,0,0,49,46,1,0,0,0,49,47,1,0,
        0,0,49,48,1,0,0,0,50,3,1,0,0,0,51,53,3,6,3,0,52,51,1,0,0,0,53,56,
        1,0,0,0,54,52,1,0,0,0,54,55,1,0,0,0,55,57,1,0,0,0,56,54,1,0,0,0,
        57,58,5,1,0,0,58,59,5,15,0,0,59,5,1,0,0,0,60,61,3,18,9,0,61,62,3,
        20,10,0,62,63,3,24,12,0,63,64,5,15,0,0,64,7,1,0,0,0,65,66,5,2,0,
        0,66,67,3,14,7,0,67,9,1,0,0,0,68,69,5,3,0,0,69,70,5,15,0,0,70,71,
        3,16,8,0,71,11,1,0,0,0,72,73,5,4,0,0,73,74,5,13,0,0,74,75,5,15,0,
        0,75,13,1,0,0,0,76,78,5,14,0,0,77,76,1,0,0,0,78,79,1,0,0,0,79,77,
        1,0,0,0,79,80,1,0,0,0,80,81,1,0,0,0,81,83,5,15,0,0,82,77,1,0,0,0,
        83,84,1,0,0,0,84,82,1,0,0,0,84,85,1,0,0,0,85,15,1,0,0,0,86,87,5,
        13,0,0,87,89,5,14,0,0,88,90,5,12,0,0,89,88,1,0,0,0,89,90,1,0,0,0,
        90,91,1,0,0,0,91,93,5,15,0,0,92,86,1,0,0,0,93,94,1,0,0,0,94,92,1,
        0,0,0,94,95,1,0,0,0,95,17,1,0,0,0,96,97,5,14,0,0,97,19,1,0,0,0,98,
        99,7,0,0,0,99,21,1,0,0,0,100,101,5,14,0,0,101,23,1,0,0,0,102,105,
        3,22,11,0,103,105,5,15,0,0,104,102,1,0,0,0,104,103,1,0,0,0,105,106,
        1,0,0,0,106,104,1,0,0,0,106,107,1,0,0,0,107,25,1,0,0,0,108,113,3,
        28,14,0,109,113,3,30,15,0,110,113,3,32,16,0,111,113,3,34,17,0,112,
        108,1,0,0,0,112,109,1,0,0,0,112,110,1,0,0,0,112,111,1,0,0,0,113,
        27,1,0,0,0,114,115,5,7,0,0,115,116,5,15,0,0,116,29,1,0,0,0,117,118,
        5,8,0,0,118,119,5,15,0,0,119,31,1,0,0,0,120,124,5,9,0,0,121,123,
        9,0,0,0,122,121,1,0,0,0,123,126,1,0,0,0,124,125,1,0,0,0,124,122,
        1,0,0,0,125,127,1,0,0,0,126,124,1,0,0,0,127,128,5,15,0,0,128,33,
        1,0,0,0,129,133,5,10,0,0,130,132,9,0,0,0,131,130,1,0,0,0,132,135,
        1,0,0,0,133,134,1,0,0,0,133,131,1,0,0,0,134,136,1,0,0,0,135,133,
        1,0,0,0,136,137,5,15,0,0,137,35,1,0,0,0,12,39,49,54,79,84,89,94,
        104,106,112,124,133
    ]

class ftrex_ftpParser ( Parser ):

    grammarFileName = "ftrex_ftp.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'ENDTREE'", "'PROCESS'", "'IMPORT'", 
                     "'LIMIT'", "'*'", "'+'", "'**CHAR32'", "'*XEQ'", "'**DBNAME:'", 
                     "'**FTITLE:'", "<INVALID>", "'I'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "NON_NEG_INTEGER", 
                      "INITIATOR_TAG", "NUMBER", "EVENT_ID", "EOL", "WS" ]

    RULE_file_ = 0
    RULE_section = 1
    RULE_treeSection = 2
    RULE_gate = 3
    RULE_processSection = 4
    RULE_importSection = 5
    RULE_limitSection = 6
    RULE_processCommands = 7
    RULE_importCommands = 8
    RULE_gateId = 9
    RULE_gateType = 10
    RULE_childRef = 11
    RULE_childRefList = 12
    RULE_metaArgs = 13
    RULE_metaEncoding = 14
    RULE_metaCmd = 15
    RULE_metaDbName = 16
    RULE_metaFTitle = 17

    ruleNames =  [ "file_", "section", "treeSection", "gate", "processSection", 
                   "importSection", "limitSection", "processCommands", "importCommands", 
                   "gateId", "gateType", "childRef", "childRefList", "metaArgs", 
                   "metaEncoding", "metaCmd", "metaDbName", "metaFTitle" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    NON_NEG_INTEGER=11
    INITIATOR_TAG=12
    NUMBER=13
    EVENT_ID=14
    EOL=15
    WS=16

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class File_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ftrex_ftpParser.EOF, 0)

        def section(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ftrex_ftpParser.SectionContext)
            else:
                return self.getTypedRuleContext(ftrex_ftpParser.SectionContext,i)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_file_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFile_" ):
                listener.enterFile_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFile_" ):
                listener.exitFile_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFile_" ):
                return visitor.visitFile_(self)
            else:
                return visitor.visitChildren(self)




    def file_(self):

        localctx = ftrex_ftpParser.File_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_file_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 18334) != 0):
                self.state = 36
                self.section()
                self.state = 41
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 42
            self.match(ftrex_ftpParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def treeSection(self):
            return self.getTypedRuleContext(ftrex_ftpParser.TreeSectionContext,0)


        def processSection(self):
            return self.getTypedRuleContext(ftrex_ftpParser.ProcessSectionContext,0)


        def importSection(self):
            return self.getTypedRuleContext(ftrex_ftpParser.ImportSectionContext,0)


        def limitSection(self):
            return self.getTypedRuleContext(ftrex_ftpParser.LimitSectionContext,0)


        def metaArgs(self):
            return self.getTypedRuleContext(ftrex_ftpParser.MetaArgsContext,0)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_section

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSection" ):
                listener.enterSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSection" ):
                listener.exitSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSection" ):
                return visitor.visitSection(self)
            else:
                return visitor.visitChildren(self)




    def section(self):

        localctx = ftrex_ftpParser.SectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_section)
        try:
            self.state = 49
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [1, 14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.treeSection()
                pass
            elif token in [2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.processSection()
                pass
            elif token in [3]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.importSection()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 4)
                self.state = 47
                self.limitSection()
                pass
            elif token in [7, 8, 9, 10]:
                self.enterOuterAlt(localctx, 5)
                self.state = 48
                self.metaArgs()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TreeSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def gate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ftrex_ftpParser.GateContext)
            else:
                return self.getTypedRuleContext(ftrex_ftpParser.GateContext,i)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_treeSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTreeSection" ):
                listener.enterTreeSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTreeSection" ):
                listener.exitTreeSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTreeSection" ):
                return visitor.visitTreeSection(self)
            else:
                return visitor.visitChildren(self)




    def treeSection(self):

        localctx = ftrex_ftpParser.TreeSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_treeSection)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==14:
                self.state = 51
                self.gate()
                self.state = 56
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 57
            self.match(ftrex_ftpParser.T__0)
            self.state = 58
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gateId(self):
            return self.getTypedRuleContext(ftrex_ftpParser.GateIdContext,0)


        def gateType(self):
            return self.getTypedRuleContext(ftrex_ftpParser.GateTypeContext,0)


        def childRefList(self):
            return self.getTypedRuleContext(ftrex_ftpParser.ChildRefListContext,0)


        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_gate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGate" ):
                listener.enterGate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGate" ):
                listener.exitGate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGate" ):
                return visitor.visitGate(self)
            else:
                return visitor.visitChildren(self)




    def gate(self):

        localctx = ftrex_ftpParser.GateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_gate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self.gateId()
            self.state = 61
            self.gateType()
            self.state = 62
            self.childRefList()
            self.state = 63
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcessSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def processCommands(self):
            return self.getTypedRuleContext(ftrex_ftpParser.ProcessCommandsContext,0)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_processSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcessSection" ):
                listener.enterProcessSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcessSection" ):
                listener.exitProcessSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcessSection" ):
                return visitor.visitProcessSection(self)
            else:
                return visitor.visitChildren(self)




    def processSection(self):

        localctx = ftrex_ftpParser.ProcessSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_processSection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.match(ftrex_ftpParser.T__1)
            self.state = 66
            self.processCommands()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def importCommands(self):
            return self.getTypedRuleContext(ftrex_ftpParser.ImportCommandsContext,0)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_importSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportSection" ):
                listener.enterImportSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportSection" ):
                listener.exitImportSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportSection" ):
                return visitor.visitImportSection(self)
            else:
                return visitor.visitChildren(self)




    def importSection(self):

        localctx = ftrex_ftpParser.ImportSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_importSection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(ftrex_ftpParser.T__2)
            self.state = 69
            self.match(ftrex_ftpParser.EOL)
            self.state = 70
            self.importCommands()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitSectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(ftrex_ftpParser.NUMBER, 0)

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_limitSection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitSection" ):
                listener.enterLimitSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitSection" ):
                listener.exitLimitSection(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitSection" ):
                return visitor.visitLimitSection(self)
            else:
                return visitor.visitChildren(self)




    def limitSection(self):

        localctx = ftrex_ftpParser.LimitSectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_limitSection)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(ftrex_ftpParser.T__3)
            self.state = 73
            self.match(ftrex_ftpParser.NUMBER)
            self.state = 74
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcessCommandsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.EOL)
            else:
                return self.getToken(ftrex_ftpParser.EOL, i)

        def EVENT_ID(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.EVENT_ID)
            else:
                return self.getToken(ftrex_ftpParser.EVENT_ID, i)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_processCommands

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcessCommands" ):
                listener.enterProcessCommands(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcessCommands" ):
                listener.exitProcessCommands(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcessCommands" ):
                return visitor.visitProcessCommands(self)
            else:
                return visitor.visitChildren(self)




    def processCommands(self):

        localctx = ftrex_ftpParser.ProcessCommandsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_processCommands)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 77 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 76
                        self.match(ftrex_ftpParser.EVENT_ID)
                        self.state = 79 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==14):
                            break

                    self.state = 81
                    self.match(ftrex_ftpParser.EOL)

                else:
                    raise NoViableAltException(self)
                self.state = 84 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportCommandsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.NUMBER)
            else:
                return self.getToken(ftrex_ftpParser.NUMBER, i)

        def EVENT_ID(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.EVENT_ID)
            else:
                return self.getToken(ftrex_ftpParser.EVENT_ID, i)

        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.EOL)
            else:
                return self.getToken(ftrex_ftpParser.EOL, i)

        def INITIATOR_TAG(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.INITIATOR_TAG)
            else:
                return self.getToken(ftrex_ftpParser.INITIATOR_TAG, i)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_importCommands

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportCommands" ):
                listener.enterImportCommands(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportCommands" ):
                listener.exitImportCommands(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportCommands" ):
                return visitor.visitImportCommands(self)
            else:
                return visitor.visitChildren(self)




    def importCommands(self):

        localctx = ftrex_ftpParser.ImportCommandsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_importCommands)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 86
                self.match(ftrex_ftpParser.NUMBER)
                self.state = 87
                self.match(ftrex_ftpParser.EVENT_ID)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==12:
                    self.state = 88
                    self.match(ftrex_ftpParser.INITIATOR_TAG)


                self.state = 91
                self.match(ftrex_ftpParser.EOL)
                self.state = 94 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==13):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateIdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_ID(self):
            return self.getToken(ftrex_ftpParser.EVENT_ID, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_gateId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateId" ):
                listener.enterGateId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateId" ):
                listener.exitGateId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateId" ):
                return visitor.visitGateId(self)
            else:
                return visitor.visitChildren(self)




    def gateId(self):

        localctx = ftrex_ftpParser.GateIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_gateId)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.match(ftrex_ftpParser.EVENT_ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GateTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NON_NEG_INTEGER(self):
            return self.getToken(ftrex_ftpParser.NON_NEG_INTEGER, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_gateType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGateType" ):
                listener.enterGateType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGateType" ):
                listener.exitGateType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGateType" ):
                return visitor.visitGateType(self)
            else:
                return visitor.visitChildren(self)




    def gateType(self):

        localctx = ftrex_ftpParser.GateTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_gateType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2144) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChildRefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT_ID(self):
            return self.getToken(ftrex_ftpParser.EVENT_ID, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_childRef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChildRef" ):
                listener.enterChildRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChildRef" ):
                listener.exitChildRef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChildRef" ):
                return visitor.visitChildRef(self)
            else:
                return visitor.visitChildren(self)




    def childRef(self):

        localctx = ftrex_ftpParser.ChildRefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_childRef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(ftrex_ftpParser.EVENT_ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChildRefListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def childRef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ftrex_ftpParser.ChildRefContext)
            else:
                return self.getTypedRuleContext(ftrex_ftpParser.ChildRefContext,i)


        def EOL(self, i:int=None):
            if i is None:
                return self.getTokens(ftrex_ftpParser.EOL)
            else:
                return self.getToken(ftrex_ftpParser.EOL, i)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_childRefList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChildRefList" ):
                listener.enterChildRefList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChildRefList" ):
                listener.exitChildRefList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChildRefList" ):
                return visitor.visitChildRefList(self)
            else:
                return visitor.visitChildren(self)




    def childRefList(self):

        localctx = ftrex_ftpParser.ChildRefListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_childRefList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 104
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [14]:
                        self.state = 102
                        self.childRef()
                        pass
                    elif token in [15]:
                        self.state = 103
                        self.match(ftrex_ftpParser.EOL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 106 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metaEncoding(self):
            return self.getTypedRuleContext(ftrex_ftpParser.MetaEncodingContext,0)


        def metaCmd(self):
            return self.getTypedRuleContext(ftrex_ftpParser.MetaCmdContext,0)


        def metaDbName(self):
            return self.getTypedRuleContext(ftrex_ftpParser.MetaDbNameContext,0)


        def metaFTitle(self):
            return self.getTypedRuleContext(ftrex_ftpParser.MetaFTitleContext,0)


        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_metaArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaArgs" ):
                listener.enterMetaArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaArgs" ):
                listener.exitMetaArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaArgs" ):
                return visitor.visitMetaArgs(self)
            else:
                return visitor.visitChildren(self)




    def metaArgs(self):

        localctx = ftrex_ftpParser.MetaArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_metaArgs)
        try:
            self.state = 112
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 108
                self.metaEncoding()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 109
                self.metaCmd()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 110
                self.metaDbName()
                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 4)
                self.state = 111
                self.metaFTitle()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaEncodingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_metaEncoding

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaEncoding" ):
                listener.enterMetaEncoding(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaEncoding" ):
                listener.exitMetaEncoding(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaEncoding" ):
                return visitor.visitMetaEncoding(self)
            else:
                return visitor.visitChildren(self)




    def metaEncoding(self):

        localctx = ftrex_ftpParser.MetaEncodingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_metaEncoding)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(ftrex_ftpParser.T__6)
            self.state = 115
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaCmdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_metaCmd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaCmd" ):
                listener.enterMetaCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaCmd" ):
                listener.exitMetaCmd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaCmd" ):
                return visitor.visitMetaCmd(self)
            else:
                return visitor.visitChildren(self)




    def metaCmd(self):

        localctx = ftrex_ftpParser.MetaCmdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_metaCmd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(ftrex_ftpParser.T__7)
            self.state = 118
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaDbNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_metaDbName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaDbName" ):
                listener.enterMetaDbName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaDbName" ):
                listener.exitMetaDbName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaDbName" ):
                return visitor.visitMetaDbName(self)
            else:
                return visitor.visitChildren(self)




    def metaDbName(self):

        localctx = ftrex_ftpParser.MetaDbNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_metaDbName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(ftrex_ftpParser.T__8)
            self.state = 124
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 121
                    self.matchWildcard() 
                self.state = 126
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

            self.state = 127
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaFTitleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOL(self):
            return self.getToken(ftrex_ftpParser.EOL, 0)

        def getRuleIndex(self):
            return ftrex_ftpParser.RULE_metaFTitle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaFTitle" ):
                listener.enterMetaFTitle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaFTitle" ):
                listener.exitMetaFTitle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaFTitle" ):
                return visitor.visitMetaFTitle(self)
            else:
                return visitor.visitChildren(self)




    def metaFTitle(self):

        localctx = ftrex_ftpParser.MetaFTitleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_metaFTitle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(ftrex_ftpParser.T__9)
            self.state = 133
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,11,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 130
                    self.matchWildcard() 
                self.state = 135
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)

            self.state = 136
            self.match(ftrex_ftpParser.EOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





